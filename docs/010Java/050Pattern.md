## 设计模式


## 面向对象思想
??? answer "答案"
    | 简写   | 翻译     |
    | ---- | ------ |
    | SRP  | 单一职责原则 |
    | OCP  | 开放封闭原则 |
    | LSP  | 里氏替换原则 |
    | ISP  | 接口分离原则 |
    | DIP  | 依赖倒置原则 |

    **单一职责原则**

    > 修改一个类的原因应该只有一个

    换句话说就是让一个类只负责一件事，当这个类需要做过多的事情的时候，就需要分解这个类。

    如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。

    **开放封闭原则**

    > 类应该对扩展开放，对修改关闭

    扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。

    符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将职责附加到对象上，而不用去修改类的代码。

    **里氏替换原则**

    > 子类对象必须能够替换掉所有父类对象

    继承是一种 IS - A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。

    如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

    **接口分离原则**

    > 不应该强迫客户依赖于它们不用的方法

    因此使用多个专门的接口比使用单一的总接口更好。

    **依赖倒置原则**

    > 高层模块不应该依赖于低层模块，两者都应该依赖于抽象。
    >
    > 抽象不应该依赖于细节，细节应该依赖于抽象。

    高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。

    依赖于抽象意味着：

    * 任何变量都不应该持有一个指向具体类的指针或者引用
    * 任何类都不应该从具体类派生
    * 任何方法都不应该覆写它的任何基类中的已经实现的方法

    #### 三大特性

    **封装**

    利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分离的独立实体。数据被保护在抽象数据类型的内部，尽可能的隐藏内部细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。

    优点：

    * 降低耦合：可以独立开发、测试、优化和修改等
    * 减轻维护的负担：可以更容易的被程序猿理解，并且在调试的时候可以不影响其他模块
    * 有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能
    * 提高软件的可重用性
    * 降低了构建大型系统的分享：即使整个系统不可用，但是这些独立的模块却有可能是可用的

    **继承**

    继承实现了 IS - A 关系，继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。

    **多态**

    多态分为编译时多态和运行时多态。编译时多态主要指方法的重载，运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定。

    运行时多态有三个条件：

    * 继承
    * 覆盖
    * 向上转型









## 代码设计的基础原则
??? answer "答案"
    代码设计的基础原则是确保代码质量、可维护性和可扩展性的关键。以下是常见的代码设计原则：

    ### 1. **KISS（Keep It Simple, Stupid）**
    - **简洁性**：代码应尽量简单，避免不必要的复杂性。
    - **易读性**：简单的代码更易理解和维护。

    ### 2. **DRY（Don't Repeat Yourself）**
    - **避免重复**：相同的代码不应在多个地方出现，应通过函数、类或模块复用。
    - **单一职责**：每个函数或类应只负责一个功能。

    ### 3. **YAGNI（You Aren't Gonna Need It）**
    - **避免过度设计**：只实现当前需要的功能，不要为未来可能的需求预先编写代码。

    ### 4. **SOLID 原则**
    - **单一职责原则（SRP）**：一个类应只有一个职责。
    - **开闭原则（OCP）**：软件实体应对扩展开放，对修改关闭。
    - **里氏替换原则（LSP）**：子类应能替换父类而不影响程序行为。
    - **接口隔离原则（ISP）**：客户端不应依赖不需要的接口。
    - **依赖倒置原则（DIP）**：高层模块不应依赖低层模块，两者都应依赖抽象。

    ### 5. **高内聚低耦合**
    - **高内聚**：模块内部元素应紧密相关，专注于单一任务。
    - **低耦合**：模块之间应尽量减少依赖，便于独立修改和测试。

    ### 6. **代码复用**
    - **模块化设计**：通过模块化提高代码复用性。
    - **库和框架**：利用现有库和框架减少重复工作。

    ### 7. **可测试性**
    - **单元测试**：代码应易于编写单元测试，确保各部分功能正确。
    - **自动化测试**：通过自动化测试减少手动测试工作量。

    ### 8. **可读性**
    - **命名规范**：使用有意义的变量、函数和类名。
    - **注释和文档**：适当注释和编写文档，帮助他人理解代码。

    ### 9. **性能与优化**
    - **避免过早优化**：先确保代码正确，再考虑性能优化。
    - **性能分析**：通过性能分析工具找出瓶颈并进行优化。

    ### 10. **安全性**
    - **输入验证**：防止注入攻击等安全问题。
    - **数据保护**：确保敏感数据的安全存储和传输。

    ### 11. **版本控制**
    - **使用版本控制系统**：如Git，便于代码管理和团队协作。
    - **分支策略**：采用合适的分支策略，如Git Flow或GitHub Flow。

    ### 12. **持续集成与持续交付（CI/CD）**
    - **自动化构建和测试**：通过CI/CD工具实现自动化构建和测试。
    - **快速反馈**：尽早发现并修复问题。

    ### 13. **代码审查**
    - **同行评审**：通过代码审查发现潜在问题，提升代码质量。
    - **知识共享**：促进团队间的知识交流。

    ### 14. **设计模式**
    - **常用设计模式**：如单例、工厂、观察者等，解决常见设计问题。
    - **模式选择**：根据具体需求选择合适的设计模式。

    ### 15. **错误处理**
    - **异常处理**：合理处理异常，避免程序崩溃。
    - **日志记录**：记录错误信息，便于问题排查。

    ### 总结
    遵循这些原则可以提升代码的可维护性、可扩展性和可读性，减少错误并提高开发效率。实际应用中，应根据项目需求灵活调整。

## 用UML画出工厂模式
??? answer "答案"

    工厂模式（Factory Pattern）是一种创建型设计模式，它提供了一种创建对象的方式，而无需指定具体的类。工厂模式通常包括以下几个角色：

    1. **产品接口（Product Interface）**：定义了产品的接口。
    2. **具体产品（Concrete Product）**：实现了产品接口的具体类。
    3. **工厂接口（Factory Interface）**：定义了创建产品的方法。
    4. **具体工厂（Concrete Factory）**：实现了工厂接口，负责创建具体产品。

    下面是一个简单的UML类图，展示了工厂模式的结构：

    ```plaintext
    +-------------------+        +-------------------+
    |   Product         |        |   Factory          |
    +-------------------+        +-------------------+
    | + operation()     |        | + createProduct()  |
    +-------------------+        +-------------------+
            ^                            ^
            |                            |
            |                            |
    +-------------------+        +-------------------+
    | ConcreteProductA  |        | ConcreteFactoryA   |
    +-------------------+        +-------------------+
    | + operation()     |        | + createProduct()  |
    +-------------------+        +-------------------+

    +-------------------+        +-------------------+
    | ConcreteProductB  |        | ConcreteFactoryB   |
    +-------------------+        +-------------------+
    | + operation()     |        | + createProduct()  |
    +-------------------+        +-------------------+
    ```

    ### 解释：
    - **Product**：产品接口，定义了产品的操作。
    - **ConcreteProductA** 和 **ConcreteProductB**：具体产品类，实现了产品接口。
    - **Factory**：工厂接口，定义了创建产品的方法。
    - **ConcreteFactoryA** 和 **ConcreteFactoryB**：具体工厂类，实现了工厂接口，负责创建具体产品。

    ### 代码示例（Java）：

    ```java
    // 产品接口
    interface Product {
        void operation();
    }

    // 具体产品A
    class ConcreteProductA implements Product {
        @Override
        public void operation() {
            System.out.println("ConcreteProductA operation");
        }
    }

    // 具体产品B
    class ConcreteProductB implements Product {
        @Override
        public void operation() {
            System.out.println("ConcreteProductB operation");
        }
    }

    // 工厂接口
    interface Factory {
        Product createProduct();
    }

    // 具体工厂A
    class ConcreteFactoryA implements Factory {
        @Override
        public Product createProduct() {
            return new ConcreteProductA();
        }
    }

    // 具体工厂B
    class ConcreteFactoryB implements Factory {
        @Override
        public Product createProduct() {
            return new ConcreteProductB();
        }
    }

    // 客户端代码
    public class FactoryPatternDemo {
        public static void main(String[] args) {
            Factory factoryA = new ConcreteFactoryA();
            Product productA = factoryA.createProduct();
            productA.operation();

            Factory factoryB = new ConcreteFactoryB();
            Product productB = factoryB.createProduct();
            productB.operation();
        }
    }
    ```

    ### 运行结果：
    ```
    ConcreteProductA operation
    ConcreteProductB operation
    ```

    这个UML图和代码示例展示了工厂模式的基本结构和实现方式。工厂模式的核心思想是将对象的创建与使用分离，使得系统更加灵活和可扩展。


## Android系统源码中，有哪些使用哪些设计模式？请列举一些常用的设计模式。
??? answer "答案"
    在Android系统源码中，设计模式被广泛用于解决常见问题并提升代码的可维护性和扩展性。以下是一些常用的设计模式及其应用场景：

    ### 1. **单例模式（Singleton）**
    - **应用场景**：确保一个类只有一个实例，并提供全局访问点。
    - **示例**：`LayoutInflater`、`InputMethodManager`等系统服务通常通过单例模式提供。

    ### 2. **工厂模式（Factory）**
    - **应用场景**：创建对象时隐藏具体实现，提供统一的接口。
    - **示例**：`BitmapFactory`用于创建`Bitmap`对象。

    ### 3. **观察者模式（Observer）**
    - **应用场景**：定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖对象都会收到通知。
    - **示例**：`LiveData`、`View`与`ViewTreeObserver`的交互。

    ### 4. **适配器模式（Adapter）**
    - **应用场景**：将一个类的接口转换成客户端期望的另一个接口。
    - **示例**：`RecyclerView.Adapter`用于将数据适配到`RecyclerView`中。

    ### 5. **装饰者模式（Decorator）**
    - **应用场景**：动态地为对象添加功能，避免通过子类扩展。
    - **示例**：`ContextWrapper`是对`Context`的装饰，允许在不修改原始类的情况下扩展功能。

    ### 6. **策略模式（Strategy）**
    - **应用场景**：定义一系列算法，封装每个算法，并使它们可以互换。
    - **示例**：`Animation`中的插值器（Interpolator）允许动态改变动画的行为。

    ### 7. **模板方法模式（Template Method）**
    - **应用场景**：定义一个算法的框架，允许子类在不改变结构的情况下重写某些步骤。
    - **示例**：`AsyncTask`中的`doInBackground`、`onPostExecute`等方法。

    ### 8. **建造者模式（Builder）**
    - **应用场景**：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
    - **示例**：`AlertDialog.Builder`用于构建`AlertDialog`。

    ### 9. **代理模式（Proxy）**
    - **应用场景**：为其他对象提供一种代理以控制对这个对象的访问。
    - **示例**：`Binder`机制中的代理对象用于跨进程通信。

    ### 10. **组合模式（Composite）**
    - **应用场景**：将对象组合成树形结构以表示“部分-整体”的层次结构。
    - **示例**：`View`和`ViewGroup`的层次结构。

    ### 11. **命令模式（Command）**
    - **应用场景**：将请求封装为对象，使得可以用不同的请求对客户进行参数化。
    - **示例**：`Runnable`和`Handler`用于封装和执行任务。

    ### 12. **状态模式（State）**
    - **应用场景**：允许对象在其内部状态改变时改变其行为。
    - **示例**：`View`的状态管理（如`View.Visibility`）。

    ### 13. **备忘录模式（Memento）**
    - **应用场景**：在不破坏封装性的前提下，捕获并外部化一个对象的内部状态。
    - **示例**：`Activity`的状态保存与恢复（`onSaveInstanceState`和`onRestoreInstanceState`）。

    ### 14. **迭代器模式（Iterator）**
    - **应用场景**：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部表示。
    - **示例**：`Cursor`用于遍历数据库查询结果。

    ### 15. **外观模式（Facade）**
    - **应用场景**：为子系统中的一组接口提供一个统一的接口。
    - **示例**：`Context`封装了访问系统资源的接口。

    这些设计模式在Android源码中广泛应用，帮助开发者构建灵活、可维护的系统架构。

## 
??? answer "答案"